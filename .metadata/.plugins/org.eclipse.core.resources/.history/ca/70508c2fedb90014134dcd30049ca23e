package gameengine.runners;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;

import javax.swing.Timer;


public class Universe {
	public static final int GAME_HOURS_IN_MILIS = 100;
	public static final int PHYSICS_UPDATE_IN_MILIS = 100;
	private static final int COLLISION_UPDATE_IN_MILIS = 100;
	public static final int DAY_DURATION = 16;
	public static final int NIGHT_DURATION = 24 - DAY_DURATION;
	public static final float changeForDayNight = 0.5f;
	public static final float NIGHT_INCREMENT = 2 * changeForDayNight
			/ (24 - DAY_DURATION);
	public static final float DAY_INCREMENT = 2 * -1 * changeForDayNight
			/ DAY_DURATION;
	public float DAY_OPACITY = 0f;
	public int tick = 0;
	public int day = 0;
	public long years = 0;
	public boolean paused = false;
	public  Timer TIME_TIMER = new Timer(GAME_HOURS_IN_MILIS,
			new ActionListener() {
				private float change;

				@Override
				public void actionPerformed(ActionEvent arg0) {
					if (paused)
						return;
					try {
						if (tick % 24 == NIGHT_DURATION) {
							change = DAY_INCREMENT;
						} else if (tick % 24 == NIGHT_DURATION / 2) {
							change = 0;// Stay at this level of darkness
						} else if (tick % 24 == NIGHT_DURATION + DAY_DURATION
								/ 2) {
							change = 0;// Stay at this level of darkness
						} else if (tick % 24 == 0) {
							change = NIGHT_INCREMENT; // Set the sun
							tick = 0;
							day++;
							TimeEvent e = new TimeEvent(day, years, tick);
							for (TimeListener lis : timeObjects) {
								lis.newDayEvent(e);
							}
						}
						tick++;
						if (day == 365) {
							day = 0;
							years++;
							TimeEvent e = new TimeEvent(day, years, tick);
							for (TimeListener lis : timeObjects) {
								lis.newYearEvent(e);
							}
						}

						TimeEvent e = new TimeEvent(day, years, tick);
						for (TimeListener lis : timeObjects) {
							lis.newHourEvent(e);
						}
						DAY_OPACITY += change;
					} catch (Exception exception) {
						System.err.println(exception.getMessage());
					}
					// System.out.println(DAY_OPACITY);
				}
			});
	/**
	 * physics engine implementation
	 */
	public Timer PHYSICS_TIMER = new Timer(PHYSICS_UPDATE_IN_MILIS,
			new ActionListener() {

				@Override
				public void actionPerformed(ActionEvent arg0) {
					// TODO Auto-generated method stub

				}

			});
	/**
	 * Collision engine implementation
	 */
	public Timer COLLISION_TIMER = new Timer(COLLISION_UPDATE_IN_MILIS,
			new ActionListener() {

				@Override
				public void actionPerformed(ActionEvent arg0) {
					// TODO Auto-generated method stub

				}

			});
	public void init() {
		TIME_TIMER.start();
		PHYSICS_TIMER.start();
		COLLISION_TIMER.stop();
	}

	public void destroy() {
		TIME_TIMER.stop();
		PHYSICS_TIMER.stop();
		COLLISION_TIMER.stop();
	}

	private static final ArrayList<TimeListener> timeObjects = new ArrayList<TimeListener>();

	public static void addTimeListener(TimeListener lis) {
		timeObjects.add(lis);
	}

	public static void removeTimeListener(TimeListener lis) {
		timeObjects.remove(lis);
	}

	private static final ArrayList<PhysicsObject> physicsObjects = new ArrayList<PhysicsObject>();

	public static void addPhysicsObject(PhysicsObject lis) {
		physicsObjects.add(lis);
	}

	public static void removePhysicObject(PhysicsObject lis) {
		physicsObjects.remove(lis);
	}
	
	private static final ArrayList<CollisionObject> collisionObjects = new ArrayList<CollisionObject>();

	public static void addCollisionObject(CollisionObject lis) {
		collisionObjects.add(lis);
	}

	public static void removeCollisionObject(CollisionObject lis) {
		collisionObjects.remove(lis);
	}
}
